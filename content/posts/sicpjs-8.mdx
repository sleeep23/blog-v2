---
title: 자바스크립트로 배우는 SICP - 8. 쌍 객체 마개조 해버리기
description: 쌍 객체를 알아보고 리스트를 구현해보자! 그리고 추상화는 덤!
createdAt: "2023-10-31"
category: 독서
timesToRead: 10
---
오늘은 쌍 객체에 대해서 다뤄볼 것이다! 그리고 쌍 객체를 이용하여 리스트 구조를 구현해볼 것이다! 그럼 키워드를 먼저 살펴보자.

## 키워드

오늘의 키워드는 다음과 같다.

- 쌍 객체와 닫힘 성질
- 순차열과 매핑

그럼 하나씩 키워드 중심으로 살펴보자!

## 쌍 객체란…?

쌍 객체란 무엇일까? 쌍 객체는 간단히 말해 쌍 자료구조가 적용된 함수라고 할 수 있다!

그럼 그 함수의 형태는 어떻게 생겼을까? (사실 이는 저번 포스팅에서 다룬 유리수를 구현하기 위해 사용했던 `pair` 함수가 대표적인 예시이다.)

우선 쌍 객체를 생성하는 `pair` 함수는 다음과 같은 구조로 이루어져있다.

```jsx
function pair(x, y) { return m => m(x, y);}
```

즉, 두 개의 인수를 받아 해당 인수들을 담은 복합 데이터 객체를 반환하는 (정확하게는 함수를 반환하는) 형태이다. 이렇게 두 인수를 받아 하나의 복합 데이터 객체를 생성하는 `pair` 함수를 `생성자`라고 지칭한다!

이렇게 생성된 복합 데이터에서 각 인수들을 빼오는 함수들은 어떻게 작성할 수 있을까? 다음 코드를 보자.

```jsx
function head(z) { return z((p, q) => p); }
function tail(z) { return z((p, q) => q); }
```

위 코드의 두 함수 `head` 와 `tail` 은 쌍 객체를 받는다는 것에 집중하자. 각 함수의 매개변수로 쌍 객체를 넣는다면, `head` 의 경우 첫 인수를, `tail` 의 경우 두 번째 인수를 반환하게 된다. 이들은 곧 `pair` 에 의해 생성된 복합 데이터 객체의 요소들인 원시 데이터 객체들에 접근, 즉 선택할 수 있는 함수들에 포함된다. 이러한 함수들을 `선택자` 라고 지칭한다!

<aside>
    💡 이렇게 `선택자` 와 `생성자` 를 중요하게 재차 언급하는 이유는 본 장에서 이야기하는 **데이터**가 이들을 바탕으로 정의되기 때문이다! 아래는 본 책의 내용인데 이 단원에서 정말 중요한 개념이니 꼭 짚고 넘어가길 바란다!

    > …, 데이터라는 것은 어떠한 선택자들과 생성자들, 그리고 유효한 표현을 위해 그 함수들이 반드시 충족하는 조건들의 집합으로 정의된다.
    >

    > … 앞에서 우리는 쌍 객체라는 것이 실제로 무엇인지는 이야기하지 않았다. 단지 우리의 언어가 쌍 객체를 다루는 함수 `pair` , `head` , `tail` 을 제공한다고 말했을 뿐이다. 우리가 이 세 연산에 관해 알아야 할 것은, `pair` 를 이용해서 두 객체를 하나의 쌍으로 붙일 수 있고 `head` 와 `tail` 을 이용해서 그 쌍에서 해당 객체들을 추출할 수 있다는 점뿐이다. 다른 말로 하면, 이 연산들은 임의의 객체 x와 y에 대해 만일 z가 `pair(x, y)` 면 `head(z)` 는 x이고 `tail(z)` 는 y라는 조건을 충족한다. … 앞의 조건을 충족하기만 한다면 그 어떤 세 함수도 쌍 객체를 구현하는 토대가 될 수 있다.
    >

    이 부분이 내 생각에는 쌍 자료구조에서 가장 곱씹어보기 좋은 파트라고 생각한다. 내가 이해한 바로는, `pair` 라는 함수는 단순하게 매개변수로 받은 인수들이 한데 모여져 있는 환경을 조성하는 그뿐 그 이상 이하도 아니다라고 결론을 내렸다. 그리고 이러한 환경에서 각 인수들을 뽑아 낼 수 있는 함수들, 즉 선택자들을 정의할 수 있을 때 비로소 이 함수로 만들어진 쌍 객체들이 데이터라는 존재가 된다는 것으로 이해했다.

</aside>

## 쌍 객체와 닫힘 성질

이처럼 쌍 객체는 복합 데이터 객체를 생성하는 데 사용할 수 있는 기본적인 접착제를 제공한다. (즉, 추상 데이터라는 가정과 그 구체적인 표현 사이에서 선택자, 생성자라는 인터페이스들이 접착제 역할을 한다는 것으로도 이해할 수 있다.) 이를 보기 쉽게 그림으로 나타내보자!

다음은 `pair(1, 2)` 가 생성하는 쌍을 상자-포인터 표기법이라는 방식으로 나타내면 다음과 같다.

![https://sicp.sourceacademy.org/img_javascript/ch2-Z-G-11.svg](https://sicp.sourceacademy.org/img_javascript/ch2-Z-G-11.svg)

조금 더 추가해볼까? 다음 예시들에 대한 그림을 보자!

- `pair(pair(1, 2), pair(3, 4))`

<Image src="/8-1.jpg" width="300" height="300" />

- `pair(pair(1, pair(2, 3)), 4)`

<Image src="/8-2.jpg" width="300" height="300" />


이제 조금 쌍에 대해서 익숙해졌을 것이다! 그리고 이러한 단순하지만 응용하기에 강력한 쌍을 잘 활용하면 타 자료구조들을 구현할 수 있겠다는 생각이 들 것이다…

다시 주제로 돌아와, 그럼 닫힘 성질과는 어떻게 연관되는 것일까?

우리가 수학에서 다루는 ‘닫힘’ 이라는 용어는, 어떤 집합과 연산이 있을 때 해당 집합의 원소들에 연산을 적용할 시 그 결과가 항상 해당 집합의 원소이면 해당 집합은 해당 연산에 대해서 닫혀있다고 정의한다. 이를 데이터 객체에 적용한 버전으로 생각하자면, 데이터 객체들을 조합하는 연산이 있을 때, 해당 연산으로 연산한 결과들을 다시 그 연산으로 조합할 수 있다면, 그 연산을 가리켜 닫힘성질을 충족한다고 말한다.

<aside>
    💡 참고로! 자바스크립트의 `클로저` 라는 개념과는 다른 의미이다! 단순히 수학에서 자주 사용되는 ‘닫혀있다’라는 개념을 활용한 것이다. 혼동하지 말자!

</aside>

### 순차열, 넌 pair 손아귀에…

가장 간단한 쌍에 대해서 닫혀있는 자료구조 예시로는 순차열이 있다! 순차열은 유용하면서도 쌍을 활용한 목록 구조로 표현할 수 있는 강력한 닫힘 성질을 지는 자료구조이다!

<aside>
    💡 본격적인 내용에 앞서 `pair(x, y)` 라는 데이터 객체는 그 출력 형태가 `[x, y]` 임을 기억하자.

    추가로 `head` 는 두 인수 중 첫 번째를, `tail` 은 두 번째 인수를 출력한다는 것으로 앞서 소개했었는데, 앞으로는 `tail` 을 나머지 부분이라고 생각하는게 이해하기 편할 것이다!

</aside>

그럼 아래 코드를 보자.

```jsx
pair(1,
     pair(2,
          pair(3,
               pair(4, null))));
```

위의 위계적인 데이터는 아래와 같은 상자-포인터 도표로 나타낼 수 있다.

![https://sicp.sourceacademy.org/img_javascript/ch2-Z-G-13.svg](https://sicp.sourceacademy.org/img_javascript/ch2-Z-G-13.svg)

이러한 순차열을 나타낼 함수를 `list` 라고 해보자. 그러면 위 코드는 아래처럼 나타낼 수 있을 것이다.(단순히 예시일 뿐이지만 이와 같은 형태로 활용할 예정이다!)

```jsx
const l = list(1, 2, 3, 4) // [1, [2, [3, [4, null]]]] 과 같은 구조를 반환할 것이다.
```

이러한 `list` 자료구조도 결국 `pair` 의 파생이기에 (`pair` 에 대해서 닫혀있기에) `head` 와 `tail` 이라는 함수를 적용할 수 있을 것이다.

```jsx
head(l) // 1이다.
tail(l) // [2, [3, [4, null]]]이다. head를 제외한 나머지 부분이다.
head(tail(l)) // 2이다. 나머지 부분의 head에 속한다.
```

어라? 그럼 결국 `pair` 에서 적용하던 연산 방식을 `list` 끼리 적용할 수 있지 않을까? 당연하다! `pair` 에서 닫혀있기 때문이다. 아래 코드를 보자.

```jsx
list(1, [2, 3], list(4, 5), 6) // [1, [[2, 3], [[4, [5, null]], [6, null]]]] 이다.
```

### 순차열 - n번째 요소 가져오기 (.at)

그럼 앞서 구현한 `list` 자료구조에서 n번째 요소를 얻어올 수 있는 방법이 있을까? (어떻게 보면, `list` 의 선택자라고 할 수도 있겠다.) 있다! 다음 코드를 보자.

```jsx
function list_ref(items, n) {
	return n === 0
				 ? head(items)
				 : list_ref(tail(items), n - 1);
}

const squares = list(1, 4, 9, 16, 25);

list_ref(squares, 3);
```

위 코드의 `list_ref` 는 items이라는 `list` 자료구조의 n번째 요소를 반복적 과정을 통해 가져오는 방법이다. 간단하 소개하면, n이 0이 될때까지 반복적 과정을 거쳐 `list_ref` 를 호출해 0인 순간 `head` 를 선택하는 것이다.

### 순차열 - 길이 구하기 (.length)

그럼 순차열의 전체 길이도 구해보자!

```jsx
function length(items) {
	function length_iter(a, count) {
		return is_null(a)
					 ? count
					 : length_iter(tail(a), count + 1);
	}
	return length_iter(items, 0);
}

const odds = list(1, 3, 5, 7);

length(odds);
```

`length` 라는 함수는 `list` 자료구조를 받아 전체 길이를 돌려준다! 함수의 구조는 어렵지 않다. 함수의 `tail` 요소가 null에 도달하기까지 반복적 과정을 거쳐 `length_iter` 라는 함수를 호출한다. 각 과정에서 `is_null` 함수를 통해 `tail` 이 null인지 그 여부를 검사한다.

### 순차열 - 뒤에 이어 붙이기 (.append)

추가로 순차열에 요소를 추가하는 append 함수에 대해서도 알아보자!

```jsx
function append(list1, list2) {
	return is_null(list1)
				 ? list2
				 : pair(head(list1), append(tail(list1), list2));
}
```

위는 다음과 같은 과정으로 두 리스트를 이어붙인다.

1. 이어 붙일 대상이 되는 `list1` 의 head를 차례대로 추출하고 쌍을 구성한다.
2. 만약 `list1` 의 head를 모두 추출하여 더 이상 추출할 게 없다면 `list2` 를 반환한다.

이와 같은 과정들을 거치면, 두 리스트를 이을 수 있을 것이다.

## 매핑(자바스크립트의 map 그거 맞습니다)

이어서 순차열에 mapping하는 기능 또한 구현해보자!

### 순차열 - 각 요소에 n배하기

자바스크립트였다면, `배열.map(i ⇒ i*n)` 처럼 구현했을 함수를 위 `list` 자료구조를 기반으로 구현해보자!

```jsx
function scale_list(items, factor) {
  return is_null(items)
				 ? null
				 : pair(head(items) * factor, scale_list(tail(items), factor));
}

scale_list(list(1, 2, 3, 4, 5), 10); // [10, [20, [30, [40, [50, null]]]]]
```

위 함수는 `list` 자료구조를 받는 items라는 인수가 null이 아닐 때까지 items의 `head` 를 추출하고 배수를 적용하기 위한 인수인 `factor` 를 곱해서 나머지 `tail` 과 쌍을 구성하는 방식으로 작성되었다. 생각해보면 append에서 구현된 방식과 그리 다르지 않다. head를 하나씩 추출하고 그 head를 가지고 어떻게 지지고 볶고 하는 것이다. 🍲 … 🤨 어라 공통된 게 있네…? 추상화?

### 각 요소를 지지고 볶자 - map

공!통!패!턴! 그럼 바로 추상화다~! 앞서 말했지만 결국 `list` 에서 추출한 `head` 에 시즈닝을 뿌리는 방식은 똑같을 것이다. 이를 추상화하면 다음과 같이 구현할 수 있을 것이다.

```jsx
function map(fn, items) {
	return is_null(items)
				 ? null
				 : pair(fn(head(items)), map(fun, tail(items)));
}
```

그럼 `map` 으로 구현한 scale_list는 다음과 같을 것이다!

```jsx
function scale_list(items, factor) {
	return map(x => x * factor, items)
}
```

위 코드를 보면, 리스트에서 추출한 head에 값에 인수로 받은 `fn` 을 적용하고 있다! 이렇게 구성한 `map` 함수는 다음과 같은 이유들로 매우 중요한 함수이다.

1. 함수가 공통의 패턴을 포착한다! → 모듈화가 가능하다
2. 목록을 다루는 좀 더 높은 추상을 확립한다

여기서 집중해야되는 점은 바로 두 번째 이유이다. 앞서 구현한 `scale_list` 와 `map` 의 가장 큰 차이점은 무엇일까? 돌아가서 코드를 보면 “**factor을 받아 리스트에서 head를 추출해 이를 곱하는**” 과정이 모두 드러나 있다는 점이다. `map` 함수를 통해 구현한 `scale_list` 에서는 이 세부사항이 숨겨져 있으며 단순하게 각 요소에 `factor` 만큼 곱한다는 람다 표현식을 활용하기에, **목록의 요소들에 비례 변환을 적용해서 새 목록을 만든다는 고수준의 개념**이 잘 드러난다. 이에 대해 책은 다음과 같이 이야기하고 있다.

> … 두 정의의 차이는 컴퓨터가 서로 다른 과정을 수행한다는 것이 아니라(실제로는 같은 과정을 수행한다), 우리가 **이 과정을 서로 다른 방식으로 생각하게 된다는 것**이다. 본질적으로 map은 **목록을 변환하는 함수**의 구현과 **목록의 요소들을 추출하고 조합하는 세부적인 방법** 사이의 **추상화 장벽**을 세우는데 도움이 된다.
>

<aside>
    👏 사실 이 부분에서 약간 감동을 느꼈다… 🥹

    지금까지 나는 개발을 하면서 수많은 라이브러리들의 함수들을 사용해왔다. 그리고 매번 이 라이브러리들을 사용하면서 지식 부채가 늘어나기 시작했다. 각각의 함수는 내부적으로 어떻게 구현되어 있으려나?

    사실 찾아보면 직관적으로 알기 힘든 함수의 이름이 적혀있다. 매번 이러한 함수를 볼 때마다 이런 함수가 어떤 일을 하는지 도대체 어떻게 알 수가 있지? 라는 고민에 빠져있다가 나오고를 반복하곤 했다. 그러면서 점점 알아야 한다고 생각하는 지식의 무게에 짓눌려 코딩 권태기가 오기도 했다.

    근데 생각해보니 내가 알려고 하던 방식은 어떻게 보면 세부적인 방법들이 모두 명세되어있는, 추상화 되어있지 않은 하나의 함수를 알려고 했던 것이 아닐까라는 생각이 내 머리를 한대 친 것 같았다!(깡!)

    이러한 시선에서 다시 라이브러리들을 들여다 봐야겠다…! 뭔가 짐이 하나 사라진 기분이다 하하.

    이렇게 보면 추상화의 장점은 그 이용에서도 있지만, 뇌속의 부하를 줄여주는 아주 이로운 장치인 것 같다는 생각도 든다 ㅎㅎㅎ

</aside>

## 마무리

이렇게 오늘은 쌍 객체와 순차열 자료구조를 구현하면서 닫힘 성질과 추상화 장벽에 대해서 알아보았다. 매번 느끼지만 이 책은 정말 유익하다. 매번 나를 놀라게 하고 매번 도움이 된다. 매 장이 고트다. 🐐 

사실 책 부분은 162쪽부터 182쪽이라 트리 부분까지 포함되지만, 트리는 그 다음 내용과 연관성이 많아 끊어가고 싶지 않아서 제외했다. 아마 다음 파트의 처음에 등장할 것이다. 이 지식들을 곱씹어가며 다음 내용을 음미해보자~ (표현이 너무 독특한가…?)

쨋든 오늘도 알찼다! 수고했다 나 자신!